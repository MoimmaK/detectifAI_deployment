"""
Backfill Embeddings for Event Descriptions

This script fixes existing event_description records in MongoDB that have
empty or invalid text_embedding fields. It generates proper 768-dim embeddings
using SentenceTransformer (all-mpnet-base-v2) ‚Äî the same model used by NLP search.

Also cleans up video_captions records with bad captions ("Unable to generate caption").

Usage:
    python backfill_embeddings.py
    python backfill_embeddings.py --dry-run    # Preview without changes
    python backfill_embeddings.py --clean-bad-captions  # Also clean bad BLIP captions
"""

import os
import sys
import argparse
import logging
from datetime import datetime
from dotenv import load_dotenv
from pymongo import MongoClient
import numpy as np

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

load_dotenv()
MONGO_URI = os.getenv(
    "MONGO_URI",
    "mongodb+srv://detectifai_user:DetectifAI123@cluster0.6f9uj.mongodb.net/detectifai?retryWrites=true&w=majority&appName=Cluster0"
)


def get_db():
    client = MongoClient(MONGO_URI)
    db = client.get_default_database()
    return db, client


def load_embedding_model():
    from sentence_transformers import SentenceTransformer
    logger.info("Loading SentenceTransformer (all-mpnet-base-v2)...")
    model = SentenceTransformer('all-mpnet-base-v2')
    logger.info("‚úÖ Model loaded")
    return model


def backfill_event_descriptions(db, model, dry_run=False):
    """Fix event_description records with missing/empty/random embeddings."""
    coll = db.get_collection("event_description")
    
    # Find records needing fix: empty embedding, or wrong dimension (384 instead of 768)
    # Also fix records that have random embeddings (generated by placeholder)
    all_docs = list(coll.find(
        {"caption": {"$exists": True, "$ne": ""}},
        {"_id": 1, "description_id": 1, "caption": 1, "text_embedding": 1}
    ))
    
    needs_fix = []
    for doc in all_docs:
        emb = doc.get("text_embedding", [])
        if not emb or len(emb) == 0:
            needs_fix.append((doc, "empty"))
        elif len(emb) != 768:
            needs_fix.append((doc, f"wrong_dim({len(emb)})"))
        else:
            # Check if it's a random/placeholder embedding (non-normalized)
            arr = np.array(emb, dtype=np.float32)
            norm = np.linalg.norm(arr)
            if abs(norm - 1.0) > 0.01:  # Properly normalized embeddings have norm ‚âà 1.0
                needs_fix.append((doc, "not_normalized"))
    
    total = len(all_docs)
    fix_count = len(needs_fix)
    
    logger.info(f"üìä Event descriptions: {total} total, {fix_count} need embedding fix")
    
    if fix_count == 0:
        logger.info("‚úÖ All event descriptions have valid embeddings!")
        return 0
    
    if dry_run:
        for doc, reason in needs_fix[:10]:
            logger.info(f"  [DRY RUN] Would fix: \"{doc.get('caption', '')[:60]}...\" ({reason})")
        if fix_count > 10:
            logger.info(f"  ... and {fix_count - 10} more")
        return fix_count
    
    # Generate embeddings in batches
    batch_size = 32
    fixed = 0
    
    for i in range(0, len(needs_fix), batch_size):
        batch = needs_fix[i:i+batch_size]
        captions = [doc.get("caption", "") for doc, _ in batch]
        
        # Batch encode for efficiency
        embeddings = model.encode(captions, normalize_embeddings=True, batch_size=batch_size)
        
        for j, (doc, reason) in enumerate(batch):
            emb = embeddings[j].astype(np.float32).tolist()
            coll.update_one(
                {"_id": doc["_id"]},
                {"$set": {
                    "text_embedding": emb,
                    "updated_at": datetime.utcnow()
                }}
            )
            fixed += 1
        
        logger.info(f"  Fixed {min(i+batch_size, fix_count)}/{fix_count} embeddings...")
    
    logger.info(f"‚úÖ Fixed {fixed} event description embeddings")
    return fixed


def clean_bad_captions(db, dry_run=False):
    """Remove video_captions with 'Unable to generate caption' from before BLIP fix."""
    coll = db.get_collection("video_captions")
    
    bad_filter = {"raw_caption": {"$regex": "Unable to generate caption", "$options": "i"}}
    bad_count = coll.count_documents(bad_filter)
    total = coll.count_documents({})
    
    logger.info(f"üìä Video captions: {total} total, {bad_count} have 'Unable to generate caption'")
    
    if bad_count == 0:
        logger.info("‚úÖ No bad captions to clean!")
        return 0
    
    if dry_run:
        bad_docs = list(coll.find(bad_filter, {"_id": 0, "video_id": 1, "frame_id": 1}).limit(5))
        for doc in bad_docs:
            logger.info(f"  [DRY RUN] Would delete: video={doc.get('video_id')}, frame={doc.get('frame_id')}")
        return bad_count
    
    result = coll.delete_many(bad_filter)
    logger.info(f"‚úÖ Deleted {result.deleted_count} bad captions")
    return result.deleted_count


def main():
    parser = argparse.ArgumentParser(description="Backfill embeddings for NLP search")
    parser.add_argument("--dry-run", action="store_true", help="Preview changes without modifying DB")
    parser.add_argument("--clean-bad-captions", action="store_true", help="Also clean bad BLIP captions")
    args = parser.parse_args()
    
    logger.info("=" * 60)
    logger.info("BACKFILL EMBEDDINGS FOR NLP SEARCH")
    logger.info("=" * 60)
    
    db, client = get_db()
    logger.info(f"Connected to MongoDB: {db.name}")
    
    model = load_embedding_model()
    
    # 1. Fix event descriptions
    logger.info("\n--- Step 1: Fix event description embeddings ---")
    fixed_embeddings = backfill_event_descriptions(db, model, dry_run=args.dry_run)
    
    # 2. Optionally clean bad BLIP captions
    if args.clean_bad_captions:
        logger.info("\n--- Step 2: Clean bad BLIP captions ---")
        cleaned_captions = clean_bad_captions(db, dry_run=args.dry_run)
    
    # Summary
    logger.info("\n" + "=" * 60)
    logger.info("SUMMARY")
    logger.info("=" * 60)
    logger.info(f"  Event embeddings fixed: {fixed_embeddings}")
    if args.clean_bad_captions:
        logger.info(f"  Bad captions cleaned: {cleaned_captions}")
    if args.dry_run:
        logger.info("  ‚ö†Ô∏è  DRY RUN ‚Äî no changes were made")
    else:
        logger.info("  ‚úÖ All changes committed to MongoDB")
    
    client.close()


if __name__ == "__main__":
    main()
