"""
Alert API Routes for DetectifAI

Flask Blueprint providing:
- SSE (Server-Sent Events) endpoint for real-time alert streaming
- REST endpoints for alert confirmation/dismissal
- Alert history and statistics
- Alert snapshot image serving
"""

import json
import time
import logging
import queue
from datetime import datetime

from flask import Blueprint, request, jsonify, Response, stream_with_context

from real_time_alerts import get_alert_engine

logger = logging.getLogger(__name__)

alert_bp = Blueprint('alerts', __name__, url_prefix='/api/alerts')


# ========================================
# SSE Stream Endpoint
# ========================================

@alert_bp.route('/stream', methods=['GET'])
def alert_stream():
    """
    SSE (Server-Sent Events) endpoint for real-time alert streaming.
    
    Frontend connects to this endpoint and receives push notifications
    whenever a new alert is generated by the live stream pipeline.
    
    Response format (SSE):
        event: alert
        data: {"alert_id": "...", "severity": "critical", ...}
    
        event: alert_update  
        data: {"alert_id": "...", "status": "confirmed", ...}
    
        event: heartbeat
        data: {"time": 1234567890}
    """
    engine = get_alert_engine()
    subscriber_queue = engine.subscribe()
    
    def event_stream():
        try:
            # Send initial connection event
            yield f"event: connected\ndata: {json.dumps({'message': 'Connected to alert stream', 'timestamp': time.time()})}\n\n"
            
            # Send any active pending alerts immediately
            active = engine.get_active_alerts()
            if active:
                yield f"event: active_alerts\ndata: {json.dumps(active)}\n\n"
            
            heartbeat_interval = 15  # seconds
            last_heartbeat = time.time()
            
            while True:
                try:
                    # Wait for alert with timeout (for heartbeat)
                    alert_data = subscriber_queue.get(timeout=heartbeat_interval)
                    
                    if alert_data is None:
                        # Poison pill â€” disconnect
                        break
                    
                    # Determine event type
                    event_type = alert_data.pop("type", "alert") if isinstance(alert_data, dict) and "type" in alert_data else "alert"
                    
                    yield f"event: {event_type}\ndata: {json.dumps(alert_data)}\n\n"
                    
                except queue.Empty:
                    # Send heartbeat to keep connection alive
                    now = time.time()
                    if now - last_heartbeat >= heartbeat_interval:
                        stats = engine.get_stats()
                        yield f"event: heartbeat\ndata: {json.dumps({'time': now, 'pending': stats.get('active_pending_count', 0)})}\n\n"
                        last_heartbeat = now
                
        except GeneratorExit:
            logger.info("SSE client disconnected")
        except Exception as e:
            logger.error(f"SSE stream error: {e}")
        finally:
            engine.unsubscribe(subscriber_queue)
    
    return Response(
        stream_with_context(event_stream()),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'X-Accel-Buffering': 'no',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*',
        }
    )


# ========================================
# Alert Actions
# ========================================

@alert_bp.route('/confirm/<alert_id>', methods=['POST'])
def confirm_alert(alert_id):
    """
    Confirm an alert as a real threat.
    
    Body (JSON):
        user_id: str (optional)
        note: str (optional)
    """
    try:
        data = request.json or {}
        user_id = data.get('user_id', 'anonymous')
        note = data.get('note', '')
        
        engine = get_alert_engine()
        result = engine.confirm_alert(alert_id, user_id=user_id, note=note)
        
        if result:
            return jsonify({
                'success': True,
                'message': f'Alert {alert_id} confirmed as real threat',
                'alert': result
            })
        else:
            return jsonify({
                'success': False,
                'error': f'Alert {alert_id} not found'
            }), 404
    
    except Exception as e:
        logger.error(f"Error confirming alert: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@alert_bp.route('/dismiss/<alert_id>', methods=['POST'])
def dismiss_alert(alert_id):
    """
    Dismiss an alert as a false positive.
    
    Body (JSON):
        user_id: str (optional)
        note: str (optional)
    """
    try:
        data = request.json or {}
        user_id = data.get('user_id', 'anonymous')
        note = data.get('note', '')
        
        engine = get_alert_engine()
        result = engine.dismiss_alert(alert_id, user_id=user_id, note=note)
        
        if result:
            return jsonify({
                'success': True,
                'message': f'Alert {alert_id} dismissed as false positive',
                'alert': result
            })
        else:
            return jsonify({
                'success': False,
                'error': f'Alert {alert_id} not found'
            }), 404
    
    except Exception as e:
        logger.error(f"Error dismissing alert: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ========================================
# Alert Queries
# ========================================

@alert_bp.route('/active', methods=['GET'])
def get_active_alerts():
    """Get all active (pending) alerts"""
    try:
        camera_id = request.args.get('camera_id')
        
        engine = get_alert_engine()
        alerts = engine.get_active_alerts(camera_id=camera_id)
        
        return jsonify({
            'success': True,
            'count': len(alerts),
            'alerts': alerts
        })
    
    except Exception as e:
        logger.error(f"Error getting active alerts: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@alert_bp.route('/history', methods=['GET'])
def get_alert_history():
    """
    Get alert history with optional filters.
    
    Query params:
        limit: int (default 50)
        camera_id: str (optional)
        severity: str (optional) - critical, high, medium, low
        status: str (optional) - pending, confirmed, dismissed
    """
    try:
        limit = int(request.args.get('limit', 50))
        camera_id = request.args.get('camera_id')
        severity = request.args.get('severity')
        status = request.args.get('status')
        
        engine = get_alert_engine()
        
        # Try to get from DB for persistence across restarts
        try:
            query = {}
            if camera_id:
                query["camera_id"] = camera_id
            if severity:
                query["severity"] = severity
            if status:
                query["status"] = status
            
            db_alerts = list(
                engine.alerts_collection.find(query)
                .sort("timestamp", -1)
                .limit(limit)
            )
            
            # Convert ObjectId to string
            for alert in db_alerts:
                alert["_id"] = str(alert["_id"])
            
            return jsonify({
                'success': True,
                'count': len(db_alerts),
                'alerts': db_alerts
            })
        except Exception:
            # Fallback to in-memory
            alerts = engine.get_alert_history(
                limit=limit, camera_id=camera_id, 
                severity=severity, status=status
            )
            return jsonify({
                'success': True,
                'count': len(alerts),
                'alerts': alerts
            })
    
    except Exception as e:
        logger.error(f"Error getting alert history: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@alert_bp.route('/<alert_id>', methods=['GET'])
def get_alert(alert_id):
    """Get a single alert by ID"""
    try:
        engine = get_alert_engine()
        alert = engine.get_alert_by_id(alert_id)
        
        if alert:
            return jsonify({'success': True, 'alert': alert})
        else:
            return jsonify({'success': False, 'error': 'Alert not found'}), 404
    
    except Exception as e:
        logger.error(f"Error getting alert: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@alert_bp.route('/stats', methods=['GET'])
def get_alert_stats():
    """Get alert statistics"""
    try:
        engine = get_alert_engine()
        stats = engine.get_stats()
        
        return jsonify({'success': True, 'stats': stats})
    
    except Exception as e:
        logger.error(f"Error getting alert stats: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@alert_bp.route('/snapshot/<alert_id>', methods=['GET'])
def get_alert_snapshot(alert_id):
    """Get the frame snapshot for an alert (proxied from MinIO)"""
    try:
        engine = get_alert_engine()
        alert = engine.get_alert_by_id(alert_id)
        
        if not alert:
            return jsonify({'success': False, 'error': 'Alert not found'}), 404
        
        snapshot_path = alert.get('frame_snapshot_path')
        if not snapshot_path:
            return jsonify({'success': False, 'error': 'No snapshot available'}), 404
        
        # Generate fresh presigned URL
        url = engine._get_snapshot_url(snapshot_path)
        if url:
            return jsonify({'success': True, 'url': url})
        else:
            return jsonify({'success': False, 'error': 'Failed to generate snapshot URL'}), 500
    
    except Exception as e:
        logger.error(f"Error getting snapshot: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ========================================
# Test Endpoint (for development)
# ========================================

@alert_bp.route('/test', methods=['POST'])
def test_alert():
    """
    Send a test alert for development/testing.
    
    Body (JSON):
        detection_class: str (e.g., 'fire', 'gun', 'fighting')
        confidence: float (0.0-1.0)
        camera_id: str (optional, default 'webcam_01')
    """
    try:
        data = request.json or {}
        detection_class = data.get('detection_class', 'fire')
        confidence = float(data.get('confidence', 0.85))
        camera_id = data.get('camera_id', 'webcam_01')
        
        engine = get_alert_engine()
        alert = engine.process_detection(
            camera_id=camera_id,
            detection_class=detection_class,
            confidence=confidence,
            timestamp=time.time(),
        )
        
        if alert:
            return jsonify({
                'success': True,
                'message': f'Test alert created: {alert.display_name}',
                'alert': alert.to_sse_payload()
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Alert was suppressed (cooldown or low confidence)'
            })
    
    except Exception as e:
        logger.error(f"Error creating test alert: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500
